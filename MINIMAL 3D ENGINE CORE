import java.util.*;

public class Mini3DEngine {
    static class Vec3 { double x,y,z; Vec3(double x,double y,double z){this.x=x;this.y=y;this.z=z;} }
    static class Mat4 {
        double[][] m = new double[4][4];
        static Mat4 identity(){ Mat4 r=new Mat4(); for(int i=0;i<4;i++) r.m[i][i]=1; return r; }
        static Mat4 rotY(double a){ Mat4 r=identity(); r.m[0][0]=Math.cos(a); r.m[0][2]=Math.sin(a); r.m[2][0]=-Math.sin(a); r.m[2][2]=Math.cos(a); return r; }
        static Mat4 proj(double fov, double aspect, double znear, double zfar){
            Mat4 r=new Mat4(); double f=1.0/Math.tan(fov/2);
            r.m[0][0]=f/aspect; r.m[1][1]=f; r.m[2][2]=(zfar+znear)/(znear-zfar); r.m[2][3]=(2*zfar*znear)/(znear-zfar); r.m[3][2]=-1;
            return r;
        }
        Vec3 mul(Vec3 v){
            double[] in = {v.x,v.y,v.z,1};
            double[] out = new double[4];
            for(int i=0;i<4;i++) for(int j=0;j<4;j++) out[i]+=m[i][j]*in[j];
            if(out[3]!=0){ out[0]/=out[3]; out[1]/=out[3]; out[2]/=out[3]; }
            return new Vec3(out[0],out[1],out[2]);
        }
        Mat4 mul(Mat4 b){
            Mat4 r=new Mat4();
            for(int i=0;i<4;i++) for(int j=0;j<4;j++){
                for(int k=0;k<4;k++) r.m[i][j]+=this.m[i][k]*b.m[k][j];
            }
            return r;
        }
    }

    static List<Vec3> cubeVerts(){
        double s=1;
        return Arrays.asList(
            new Vec3(-s,-s,-s), new Vec3(s,-s,-s), new Vec3(s,s,-s), new Vec3(-s,s,-s),
            new Vec3(-s,-s,s),  new Vec3(s,-s,s),  new Vec3(s,s,s),  new Vec3(-s,s,s)
        );
    }
    static int[][] edges = {
        {0,1},{1,2},{2,3},{3,0},
        {4,5},{5,6},{6,7},{7,4},
        {0,4},{1,5},{2,6},{3,7}
    };

    public static void main(String[] args) throws InterruptedException {
        List<Vec3> verts = cubeVerts();
        Mat4 proj = Mat4.proj(Math.toRadians(90), 1.5, 0.1, 100);
        double angle=0;
        int W=80,H=24;
        while(angle < Math.PI*2){
            Mat4 rot = Mat4.rotY(angle);
            Mat4 modelView = Mat4.identity();
            modelView.m[2][3] = -5; // translate back
            Mat4 mvp = proj.mul(modelView).mul(rot);
            char[][] screen = new char[H][W];
            for(char[] row: screen) Arrays.fill(row, ' ');
            List<Vec3> pts = new ArrayList<>();
            for(Vec3 v: verts){
                Vec3 p = mvp.mul(v);
                int x = (int)((p.x+1)*0.5*W);
                int y = (int)((1-(p.y+1)*0.5)*H);
                pts.add(new Vec3(x,y,0));
            }
            for(int[] e: edges){
                drawLine(screen, (int)pts.get(e[0]).x, (int)pts.get(e[0]).y, (int)pts.get(e[1]).x, (int)pts.get(e[1]).y);
            }
            System.out.println("\u001b[H\u001b[2J");
            for(int i=0;i<H;i++) System.out.println(new String(screen[i]));
            Thread.sleep(100);
            angle += 0.1;
        }
    }

    static void drawLine(char[][] screen, int x0, int y0, int x1, int y1){
        int dx=Math.abs(x1-x0), dy=Math.abs(y1-y0);
        int sx=x0<x1?1:-1, sy=y0<y1?1:-1;
        int err = dx-dy;
        while(true){
            if(y0>=0 && y0<screen.length && x0>=0 && x0<screen[0].length) screen[y0][x0] = '#';
            if(x0==x1 && y0==y1) break;
            int e2=2*err;
            if(e2> -dy){ err -= dy; x0 += sx; }
            if(e2< dx){ err += dx; y0 += sy; }
        }
    }
}
